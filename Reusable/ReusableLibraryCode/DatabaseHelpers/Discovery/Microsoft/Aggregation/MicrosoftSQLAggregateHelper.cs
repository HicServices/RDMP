using System;
using System.Collections.Generic;
using System.Linq;
using ReusableLibraryCode.DatabaseHelpers.Discovery.QuerySyntax;
using ReusableLibraryCode.DatabaseHelpers.Discovery.QuerySyntax.Aggregation;

namespace ReusableLibraryCode.DatabaseHelpers.Discovery.Microsoft.Aggregation
{
    public class MicrosoftSQLAggregateHelper : IAggregateHelper
    {
        private string GetDateAxisTableDeclaration(IQueryAxis axis)
        {
            //if pivot dimension is set then this code appears inside dynamic SQL constant string that will be Exec'd so we have to escape single quotes 
            string startDateSql = axis.StartDate;
            string endDateSql = axis.EndDate;
            
    return String.Format(
@"
    DECLARE	@startDate DATE
    DECLARE	@endDate DATE

    SET @startDate = {0}
    SET @endDate = {1}

    DECLARE @dateAxis TABLE
    (
	    dt DATE
    )

    DECLARE @currentDate DATE = @startDate

    WHILE @currentDate <= @endDate
    BEGIN
	    INSERT INTO @dateAxis 
		    SELECT @currentDate 

	    SET @currentDate = DATEADD({2}, 1, @currentDate)

    END
", startDateSql, endDateSql, axis.AxisIncrement);
        
        }

        public string GetAxisTableRuntimeName()
        {
            return "axis";
        }

        public string GetAxisTableNameFullyQualified()
        {
            return "@dateAxis axis";
        }
        
        /// <summary>
        /// Takes the fieldname/transform from the dataset and wraps it with the date adjustment function specified by the AxisIncrement
        /// </summary>
        /// <param name="increment"></param>
        /// <param name="columnSql"></param>
        /// <returns></returns>
        public string GetDatePartOfColumn(AxisIncrement increment, string columnSql)
        {
            switch (increment)
            {
                case AxisIncrement.Day:
                    return " Convert(date, " + columnSql + ")"; //Handles when there are times in the field by always converting to date
                case AxisIncrement.Month:
                    return " CONVERT(nvarchar(7)," + columnSql + ",126)"; //returns 2015-01
                case AxisIncrement.Year:
                    return " YEAR(" + columnSql + ")"; //returns 2015
                case AxisIncrement.Quarter:
                    return " DATENAME(year, " + columnSql + ") +'Q' + DATENAME(quarter," + columnSql + ")"; //returns 2015Q1
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        /// Gives you the equivalency check for the given axis joined to column1 column.  Use this in the JOIN SQL generated by AggregateBuilder 
        /// </summary>
        /// <param name="column1">The column name or transform from the dataset</param>
        /// <param name="column2">The axis column e.g. axis.dt</param>
        /// <returns></returns>
        public string GetDatePartBasedEqualsBetweenColumns(AxisIncrement increment, string column1, string column2)
        {
            switch (increment)
            {
                case AxisIncrement.Day:
                    return GetDatePartOfColumn(increment,column1) + "=" + column2;//truncate any time off column1, column2 is the axis column which never has time anyway
                case AxisIncrement.Month:
                    return string.Format("YEAR({0}) = YEAR({1}) AND MONTH({0}) = MONTH({1})", column1, column2); //for performance
                case AxisIncrement.Year:
                    return GetDatePartOfColumn(increment, column1) + "=" + GetDatePartOfColumn(increment, column2);
                case AxisIncrement.Quarter:
                    return string.Format("YEAR({0}) = YEAR({1}) AND DATEPART(QUARTER, {0}) = DATEPART(QUARTER, {1})", column1, column2);
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }


        private string BuildAxisAggregate(List<CustomLine> lines, IQueryAxis axis)
        {
            var syntaxHelper = new MicrosoftQuerySyntaxHelper();

            var countSelectLine = lines.Single(l => l.LocationToInsert == QueryComponent.QueryTimeColumn && l.Role == CustomLineRole.CountFunction);

            string countSqlWithoutAlias;
            string countAlias;
            syntaxHelper.SplitLineIntoSelectSQLAndAlias(countSelectLine.Text, out countSqlWithoutAlias, out countAlias);

            CustomLine axisColumn;
            string axisColumnWithoutAlias;
            CustomLine axisGroupBy;
            string axisColumnAlias;
            AdjustAxisQueryLines(lines, axis, syntaxHelper, out axisColumn, out axisColumnWithoutAlias,out axisColumnAlias, out axisGroupBy);

            return string.Format(
                @"
{0}
{1}

SELECT 
{2} AS joinDt,dataset.{3}
FROM
@dateAxis axis
LEFT JOIN
(
    {4}
) dataset
ON dataset.{5} = {2}
ORDER BY 
{2}
"
                ,
                string.Join(Environment.NewLine, lines.Where(c => c.LocationToInsert < QueryComponent.SELECT)),
                GetDateAxisTableDeclaration(axis),

                GetDatePartOfColumn(axis.AxisIncrement, "axis.dt"),
                countAlias,

                //the entire query
                string.Join(Environment.NewLine, lines.Where(c => c.LocationToInsert >= QueryComponent.SELECT && c.LocationToInsert <= QueryComponent.Having)),
                axisColumnAlias
                ).Trim();
        }

        private void AdjustAxisQueryLines(List<CustomLine> lines, IQueryAxis axis, MicrosoftQuerySyntaxHelper syntaxHelper,out CustomLine axisColumn, out string axisColumnWithoutAlias,out string axisColumnAlias, out CustomLine axisGroupBy)
        {
            //Deal with the axis dimension which is currently [mydb].[mytbl].[mycol] and needs to become YEAR([mydb].[mytbl].[mycol]) As joinDt 
            axisColumn = lines.Single(l => l.LocationToInsert == QueryComponent.QueryTimeColumn && l.Role == CustomLineRole.Axis);

            syntaxHelper.SplitLineIntoSelectSQLAndAlias(axisColumn.Text, out axisColumnWithoutAlias, out axisColumnAlias);

            axisGroupBy = lines.Single(l => l.LocationToInsert == QueryComponent.GroupBy && l.Role == CustomLineRole.Axis);

            if (string.IsNullOrWhiteSpace(axisColumnAlias))
                axisColumnAlias = "joinDt";

            var axisColumnEndedWithComma = axisColumn.Text.EndsWith(",");
            axisColumn.Text = GetDatePartOfColumn(axis.AxisIncrement, axisColumnWithoutAlias) + " AS " + axisColumnAlias +
                              (axisColumnEndedWithComma ? "," : "");

            var groupByEndedWithComma = axisGroupBy.Text.EndsWith(",");
            axisGroupBy.Text = GetDatePartOfColumn(axis.AxisIncrement, axisColumnWithoutAlias) +
                               (groupByEndedWithComma ? "," : "");
            
        }


        private string BuildPivotAggregate(List<CustomLine> lines, IQueryAxis axis)
        {
            var syntaxHelper = new MicrosoftQuerySyntaxHelper();

            //find the pivot column e.g. 'hb_extract AS Healthboard'
            var pivotSelectLine = lines.Single(l => l.LocationToInsert == QueryComponent.QueryTimeColumn && l.Role == CustomLineRole.Pivot);
            
            //the LHS e.g. hb_extract
            string pivotSqlWithoutAlias;
            //the RHS e.g. Healthboard
            string pivotAlias;
            syntaxHelper.SplitLineIntoSelectSQLAndAlias(pivotSelectLine.Text,out pivotSqlWithoutAlias,out pivotAlias);

            //ensure it has an RHS
            if (string.IsNullOrWhiteSpace(pivotAlias))
                pivotAlias = syntaxHelper.GetRuntimeName(pivotSqlWithoutAlias);

            var countSelectLine = lines.Single(l => l.LocationToInsert == QueryComponent.QueryTimeColumn && l.Role == CustomLineRole.CountFunction);

            string countSqlWithoutAlias;
            string countAlias;
            syntaxHelper.SplitLineIntoSelectSQLAndAlias(countSelectLine.Text, out countSqlWithoutAlias, out countAlias);

            CustomLine axisColumn;
            string axisColumnWithoutAlias;
            CustomLine axisGroupBy;
            string axisColumnAlias;
            AdjustAxisQueryLines(lines, axis, syntaxHelper, out axisColumn, out axisColumnWithoutAlias, out axisColumnAlias, out axisGroupBy);

            //Part 1 is where we get all the unique values from the pivot column (after applying the WHERE logic)

            bool anyFilters = lines.Any(l => l.LocationToInsert == QueryComponent.WHERE);

            string orderBy = countSqlWithoutAlias + " desc";
            var topXOrderByLine = lines.SingleOrDefault(l => l.LocationToInsert == QueryComponent.OrderBy && l.Role == CustomLineRole.TopX);

            if (topXOrderByLine != null)
                orderBy = topXOrderByLine.Text;

            string havingSqlIfAny = string.Join(Environment.NewLine,
                lines.Where(l => l.LocationToInsert == QueryComponent.Having).Select(l => l.Text));

            string part1 = string.Format(
               @"
/*DYNAMICALLY FETCH COLUMN VALUES FOR USE IN PIVOT*/
DECLARE @Columns as VARCHAR(MAX)
{0}

/*Get distinct values of the PIVOT Column if you have columns with values T and F and Z this will produce [T],[F],[Z] and you will end up with a pivot against these values*/
set @Columns = (
{1}
 ',' + QUOTENAME({2}) as [text()] 
{3}
{4}
{5} ( {2} IS NOT NULL and {2} <> '' AND  {7} is not null)
group by 
{2}
{8}
order by 
{6}
FOR XML PATH(''), root('MyString'),type
).value('/MyString[1]','varchar(max)')

set @Columns = SUBSTRING(@Columns,2,LEN(@Columns))

DECLARE @FinalSelectList as VARCHAR(MAX)
SET @FinalSelectList = 'joinDt'

--Split up that pesky string in tsql which has the column names up into array elements again
DECLARE @value varchar(8000)
DECLARE @pos INT
DECLARE @len INT
set @pos = 0
set @len = 0

WHILE CHARINDEX('],', @Columns +',', @pos+1)>0
BEGIN
    set @len = CHARINDEX('],[', @Columns +'],[', @pos+1) - @pos
    set @value = SUBSTRING(@Columns, @pos+1, @len)
        
    --We are constructing a version that turns: '[fish],[lama]' into 'ISNULL([fish],0) as [fish], ISNULL([lama],0) as [lama]'
    SET @FinalSelectList = @FinalSelectList + ', ISNULL(' + @value  + ',0) as ' + @value

    set @pos = CHARINDEX('],[', @Columns +'],[', @pos+@len) +1
END

",
                                                  //select SQL and parameter declarations
                                                  string.Join(Environment.NewLine, lines.Where(l => l.LocationToInsert < QueryComponent.SELECT)),
                                                  string.Join(Environment.NewLine,lines.Where(l=>l.LocationToInsert == QueryComponent.SELECT)),
                                                   pivotSqlWithoutAlias,
                                                  
                                                  //FROM and JOINs that are not to the calendar table
                                                  string.Join(Environment.NewLine,lines.Where(l=>l.LocationToInsert == QueryComponent.FROM || l.LocationToInsert == QueryComponent.JoinInfoJoin && l.Role != CustomLineRole.Axis)),
                                                  
                                                  string.Join(Environment.NewLine,lines.Where(l=>l.LocationToInsert == QueryComponent.WHERE)),
                                                  anyFilters ? "AND" : "WHERE",
                                                  orderBy,
                                                  axisColumnWithoutAlias,
                                                  havingSqlIfAny
                                                  );

           //The dynamic query in which we assemble a query string and EXECUTE it
           string part2 = string.Format(@"
/*DYNAMIC PIVOT*/
declare @Query varchar(MAX)

SET @Query = '
{0}
{1}

/*Would normally be Select * but must make it IsNull to ensure we see 0s instead of null*/
select '+@FinalSelectList+'
from
(

SELECT
    {5} as joinDt,
    {4},
    {3}
    FROM
    @dateAxis axis
    LEFT JOIN
    (
        {2}
    )ds
    on {5} = ds.{6}
) s
PIVOT
(
	sum({3})
	for {4} in ('+@Columns+') --The dynamic Column list we just fetched at top of query
) piv'

EXECUTE(@Query)
",
 syntaxHelper.Escape(string.Join(Environment.NewLine, lines.Where(c => c.LocationToInsert < QueryComponent.SELECT))),
 syntaxHelper.Escape(GetDateAxisTableDeclaration(axis)),
 
 //the entire select query up to the end of the group by (ommitting any Top X)
 syntaxHelper.Escape(string.Join(Environment.NewLine, lines.Where(c =>
     c.LocationToInsert >= QueryComponent.SELECT && 
     c.LocationToInsert < QueryComponent.OrderBy  &&
     c.Role != CustomLineRole.TopX))),

     syntaxHelper.Escape(countAlias),
     syntaxHelper.Escape(pivotAlias),
     syntaxHelper.Escape(GetDatePartOfColumn(axis.AxisIncrement,"axis.dt")),
     axisColumnAlias
 );
           
           return part1 + part2;
        }


        public string BuildAggregate(List<CustomLine> queryLines, IQueryAxis axisIfAny, bool pivot)
        {
      if (axisIfAny == null && !pivot)
                return string.Join(Environment.NewLine, queryLines);

            if (!pivot)
                //axis but no pivot
                return BuildAxisAggregate(queryLines, axisIfAny);
            
            //axis and pivot (cannot pivot without axis)
            if (axisIfAny == null)
                throw new NotSupportedException("Expected there to be both a pivot and an axis");

            return BuildPivotAggregate(queryLines, axisIfAny);
        }

    }
}
