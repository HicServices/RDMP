// Copyright (c) The University of Dundee 2018-2019
// This file is part of the Research Data Management Platform (RDMP).
// RDMP is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
// RDMP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with RDMP. If not, see <https://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Rdmp.Core.MapsDirectlyToDatabaseTable;
using Rdmp.Core.Repositories;
using Rdmp.Core.ReusableLibraryCode.Annotations;

namespace Rdmp.Core.Curation.Data.Dashboarding;

/// <summary>
///     Helps you create simple string based argument lists
/// </summary>
public static class PersistStringHelper
{
    /// <summary>
    ///     The string to use to divide objects declared within a collection e.g. ',' in
    ///     [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </summary>
    public const char CollectionObjectSeparator = ',';

    /// <summary>
    ///     The string to use to indicate the start of an objects collection e.g. '[' in
    ///     [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </summary>
    public const char CollectionStartDelimiter = '[';

    /// <summary>
    ///     The string to use to indicate the end of an objects collection e.g. ']' in
    ///     [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </summary>
    public const char CollectionEndDelimiter = ']';

    /// <summary>
    ///     The string to use to separate logic portions of a persistence string e.g. ':"  in
    ///     [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </summary>
    public const char Separator = ':';

    /// <summary>
    ///     Divider between Type section  (see <see cref="Separator" /> - what is the control) and args dictionary for
    ///     IPersistableObjectCollection
    /// </summary>
    public const string ExtraText = "###EXTRA_TEXT###";

    /// <summary>
    ///     Serializes the dictionary to a string of XML
    /// </summary>
    /// <param name="dict"></param>
    /// <returns></returns>
    public static string SaveDictionaryToString(Dictionary<string, string> dict)
    {
        var el = new XElement("root",
            dict.Select(static kv => new XElement(kv.Key, kv.Value)));

        return el.ToString();
    }

    /// <summary>
    ///     Creates a dictionary by deserializing the XML string provided (e.g. a string generated by
    ///     <see cref="SaveDictionaryToString" />)
    /// </summary>
    /// <param name="str"></param>
    /// <returns></returns>
    public static Dictionary<string, string> LoadDictionaryFromString(string str)
    {
        if (string.IsNullOrWhiteSpace(str))
            return new Dictionary<string, string>();

        var rootElement = XElement.Parse(str);
        return rootElement.Elements().ToDictionary(el => el.Name.LocalName, el => el.Value);
    }

    /// <summary>
    ///     Fetches the given key from the serialized <paramref name="persistString" /> (e.g. a string generated by
    ///     <see cref="SaveDictionaryToString" />)
    ///     <para>If you need lots of values you should probably just use <see cref="LoadDictionaryFromString" /> instead</para>
    /// </summary>
    /// <param name="key"></param>
    /// <param name="persistString"></param>
    /// <returns></returns>
    public static string GetValueIfExistsFromPersistString(string key, string persistString)
    {
        var dict = LoadDictionaryFromString(persistString);

        return dict.TryGetValue(key, out var s) ? s : null;
    }

    /// <summary>
    ///     Returns the objects IDs formatted with the <see cref="CollectionStartDelimiter" />,
    ///     <see cref="CollectionEndDelimiter" /> and <see cref="CollectionObjectSeparator" />
    /// </summary>
    /// <param name="objects"></param>
    /// <returns></returns>
    public static string GetObjectCollectionPersistString(params IMapsDirectlyToDatabaseTable[] objects)
    {
        var sb = new StringBuilder();

        //output [obj1,obj2,obj3]
        sb.Append(CollectionStartDelimiter);

        //where obj is <RepositoryType>:<DatabaseObjectType>:<ObjectID>
        sb.Append(string.Join(CollectionObjectSeparator,
            objects.Select(o =>
                o.Repository.GetType().FullName + Separator + o.GetType().FullName + Separator + o.ID)));

        //ending bracket for the object collection
        sb.Append(CollectionEndDelimiter);

        return sb.ToString();
    }

    private static readonly Regex CollectionPattern =
        new($"{Regex.Escape(CollectionStartDelimiter.ToString())}(.*){Regex.Escape(CollectionEndDelimiter.ToString())}",
            RegexOptions.CultureInvariant);

    /// <summary>
    ///     Returns the object list section of any <paramref name="persistenceString" />. This string must take the format
    ///     [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    ///     <para>
    ///         Throws <see cref="PersistenceException" /> if there is not exactly 1 match or if the number of subtokens in
    ///         each section is not 3.
    ///     </para>
    /// </summary>
    /// <param name="persistenceString">persistence string in the format [RepoType:ObjectType:ID,RepoType:ObjectType:ID]</param>
    /// <returns></returns>
    public static string MatchCollectionInString(string persistenceString)
    {
        try
        {
            //match the starting delimiter
            var pattern =
                $"{Regex.Escape(CollectionStartDelimiter.ToString())}(.*){Regex.Escape(CollectionEndDelimiter.ToString())}"; //then the ending delimiter

            return Regex.Match(persistenceString, pattern).Groups[1].Value;
        }
        catch (Exception e)
        {
            throw new PersistenceException(
                $"Could not match ObjectCollection delimiters in persistenceString '{persistenceString}'", e);
        }
    }


    /// <summary>
    ///     Fetches the listed objects out of the collection section of a persistence string by fetching the listed ObjectType
    ///     by ID from the RepoType
    /// </summary>
    /// <param name="allObjectsString">
    ///     A string with a list of objects ID's, should have the format
    ///     [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </param>
    /// <param name="repositoryLocator"></param>
    /// <returns></returns>
    public static List<IMapsDirectlyToDatabaseTable> GetObjectCollectionFromPersistString(string allObjectsString,
        IRDMPPlatformRepositoryServiceLocator repositoryLocator)
    {
        var toReturn = new List<IMapsDirectlyToDatabaseTable>();

        allObjectsString = allObjectsString.Trim(CollectionStartDelimiter, CollectionEndDelimiter);

        var objectStrings =
            allObjectsString.Split(new[] { CollectionObjectSeparator }, StringSplitOptions.RemoveEmptyEntries);

        foreach (var objectString in objectStrings)
        {
            var objectTokens = objectString.Split(Separator);

            if (objectTokens.Length != 3)
                throw new PersistenceException(
                    $"Could not figure out what database object to fetch because the list contained an item with an invalid number of tokens ({objectTokens.Length} tokens).  The current object string is:{Environment.NewLine}{objectString}");

            var dbObj = repositoryLocator.GetArbitraryDatabaseObject(objectTokens[0], objectTokens[1],
                int.Parse(objectTokens[2]));

            if (dbObj != null)
                toReturn.Add(dbObj);
            else
                throw new PersistenceException(
                    $"DatabaseObject '{objectString}' has been deleted meaning IPersistableObjectCollection could not be properly created/populated");
        }

        return toReturn;
    }

    /// <summary>
    ///     Returns all text appearing after <see cref="ExtraText" />
    /// </summary>
    /// <param name="persistString"></param>
    /// <returns></returns>
    public static string GetExtraText(string persistString)
    {
        return !persistString.Contains(ExtraText)
            ? null
            : persistString[(persistString.IndexOf(ExtraText, StringComparison.Ordinal) + ExtraText.Length)..];
    }


    /// <summary>
    ///     Returns the value of <paramref name="dict" /> corresponding to <paramref name="key" />.  If not in the dictionary
    ///     then <paramref name="valueIfMissing" /> is returned
    /// </summary>
    /// <param name="dict"></param>
    /// <param name="key"></param>
    /// <param name="valueIfMissing"></param>
    /// <returns></returns>
    public static bool GetBool([CanBeNull] Dictionary<string, string> dict, string key, bool valueIfMissing)
    {
        return dict?.TryGetValue(key, out var value) != true ? valueIfMissing : bool.Parse(value);
    }
}