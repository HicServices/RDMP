// Copyright (c) The University of Dundee 2018-2019
// This file is part of the Research Data Management Platform (RDMP).
// RDMP is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
// RDMP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with RDMP. If not, see <https://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Rdmp.Core.MapsDirectlyToDatabaseTable;
using Rdmp.Core.Repositories;

namespace Rdmp.Core.Curation.Data.Dashboarding;

/// <summary>
/// Helps you create simple string based argument lists
/// </summary>
public static class PersistStringHelper
{

    /// <summary>
    /// The string to use to divide objects declared within a collection e.g. ',' in [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </summary>
    public const char CollectionObjectSeparator = ',';

    /// <summary>
    /// The string to use to indicate the start of an objects collection e.g. '[' in  [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </summary>
    public const char CollectionStartDelimiter = '[';

    /// <summary>
    /// The string to use to indicate the end of an objects collection e.g. ']' in  [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </summary>
    public const char CollectionEndDelimiter = ']';

    /// <summary>
    /// The string to use to separate logic portions of a persistence string e.g. ':"  in  [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// </summary>
    public const char Separator = ':';

    /// <summary>
    /// Divider between Type section  (see <see cref="Separator"/> - what is the control) and args dictionary for IPersistableObjectCollection
    /// </summary>
    public const string ExtraText = "###EXTRA_TEXT###";

    /// <summary>
    /// Serializes the dictionary to a string of XML
    /// </summary>
    /// <param name="dict"></param>
    /// <returns></returns>
    public static string SaveDictionaryToString(Dictionary<string, string> dict)
    {
        var el = new XElement("root",
            dict.Select(static kv => new XElement(kv.Key, kv.Value)));

        return el.ToString();
    }

    /// <summary>
    /// Creates a dictionary by deserializing the XML string provided (e.g. a string generated by <see cref="SaveDictionaryToString"/>)
    /// </summary>
    /// <param name="str"></param>
    /// <returns></returns>
    public static Dictionary<string, string> LoadDictionaryFromString(string str)
    {
        if(string.IsNullOrWhiteSpace(str))
            return new Dictionary<string, string>();

        var rootElement = XElement.Parse(str);
        return rootElement.Elements().ToDictionary(el => el.Name.LocalName, el => el.Value);
    }

    /// <summary>
    /// Fetches the given key from the serialized <paramref name="persistString"/> (e.g. a string generated by <see cref="SaveDictionaryToString"/>)
    /// 
    /// <para>If you need lots of values you should probably just use <see cref="LoadDictionaryFromString"/> instead</para>
    /// </summary>
    /// <param name="key"></param>
    /// <param name="persistString"></param>
    /// <returns></returns>
    public static string GetValueIfExistsFromPersistString(string key, string persistString)
    {
        var dict = LoadDictionaryFromString(persistString);

        return dict.TryGetValue(key, out var s) ? s : null;
    }

    /// <summary>
    /// Returns the objects IDs formatted with the <see cref="CollectionStartDelimiter"/>, <see cref="CollectionEndDelimiter"/> and <see cref="CollectionObjectSeparator"/>
    /// </summary>
    /// <param name="objects"></param>
    /// <returns></returns>
    public static string GetObjectCollectionPersistString(params IMapsDirectlyToDatabaseTable[] objects)
    {
        var sb = new StringBuilder();

        //output [obj1,obj2,obj3]
        sb.Append(CollectionStartDelimiter);

        //where obj is <RepositoryType>:<DatabaseObjectType>:<ObjectID>
        sb.Append(string.Join(CollectionObjectSeparator, objects.Select(o => o.Repository.GetType().FullName + Separator + o.GetType().FullName + Separator + o.ID)));
            
        //ending bracket for the object collection
        sb.Append(CollectionEndDelimiter);

        return sb.ToString();
    }

    private static readonly Regex CollectionPattern =
        new($"{Regex.Escape(CollectionStartDelimiter.ToString())}(.*){Regex.Escape(CollectionEndDelimiter.ToString())}",
            RegexOptions.CultureInvariant);

    /// <summary>
    /// Returns the object list section of any <paramref name="persistenceString"/>. This string must take the format [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
    /// 
    /// <para>Throws <see cref="PersistenceException"/> if there is not exactly 1 match or if the number of subtokens in each section is not 3.</para>
    /// </summary>
    /// <param name="persistenceString">persistence string in the format [RepoType:ObjectType:ID,RepoType:ObjectType:ID]</param>
    /// <returns></returns>
    public static string MatchCollectionInString(string persistenceString)
    {
        try
        {
            //match the starting delimiter
            var pattern =
                $"{Regex.Escape(CollectionStartDelimiter.ToString())}(.*){Regex.Escape(CollectionEndDelimiter.ToString())}";//then the ending delimiter

            return Regex.Match(persistenceString, pattern).Groups[1].Value;
        }
        catch (Exception e)
        {
            throw new PersistenceException(
                $"Could not match ObjectCollection delimiters in persistenceString '{persistenceString}'", e);
        }
    }


    /// <summary>
    /// Fetches the listed objects out of the collection section of a persistence string by fetching the listed ObjectType by ID from the RepoType
    /// </summary>
    /// <param name="allObjectsString">A string with a list of objects ID's, should have the format [RepoType:ObjectType:ID,RepoType:ObjectType:ID]</param>
    /// <param name="repositoryLocator"></param>
    /// <returns></returns>
    public static List<IMapsDirectlyToDatabaseTable> GetObjectCollectionFromPersistString(string allObjectsString, IRDMPPlatformRepositoryServiceLocator repositoryLocator)
    {
        var toReturn = new List<IMapsDirectlyToDatabaseTable>();

        allObjectsString = allObjectsString.Trim(CollectionStartDelimiter, CollectionEndDelimiter);

        var objectStrings =
            allObjectsString.Split(new[] { CollectionObjectSeparator }, StringSplitOptions.RemoveEmptyEntries);

        foreach (var objectString in objectStrings)
        {
            var objectTokens = objectString.Split(Separator);

            if (objectTokens.Length != 3)
                throw new PersistenceException(
                    $"Could not figure out what database object to fetch because the list contained an item with an invalid number of tokens ({objectTokens.Length} tokens).  The current object string is:{Environment.NewLine}{objectString}");

            var dbObj = repositoryLocator.GetArbitraryDatabaseObject(objectTokens[0], objectTokens[1], int.Parse(objectTokens[2]));

            if (dbObj != null)
                toReturn.Add(dbObj);
            else
                throw new PersistenceException(
                    $"DatabaseObject '{objectString}' has been deleted meaning IPersistableObjectCollection could not be properly created/populated");
        }

        return toReturn;
    }

    /// <summary>
    /// Returns all text appearing after <see cref="ExtraText"/>
    /// </summary>
    /// <param name="persistString"></param>
    /// <returns></returns>
    public static string GetExtraText(string persistString)
    {
        return !persistString.Contains(ExtraText) ? null : persistString[(persistString.IndexOf(ExtraText, StringComparison.Ordinal) + ExtraText.Length)..];
    }


    /// <summary>
    /// Returns the value of <paramref name="dict"/> corresponding to <paramref name="key"/>.  If not in the dictionary
    /// then <paramref name="valueIfMissing"/> is returned
    /// </summary>
    /// <param name="dict"></param>
    /// <param name="key"></param>
    /// <param name="valueIfMissing"></param>
    /// <returns></returns>
    public static bool GetBool(Dictionary<string, string> dict, string key, bool valueIfMissing)
    {
        if (dict == null || !dict.ContainsKey(key))
            return valueIfMissing;

        return bool.Parse(dict[key]);
    }
}